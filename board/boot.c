#include <stdbool.h>
#include <stdint.h>

#include "gpio.h"
#include "wdog.h"
#include "UniTimeX.h"

#include "GD32E503.h"
#include "BitCodec.h"


int boot(void)
{
	//
	// Clock and PLL
	//
	
	// GD32E503_RCU_CTL
	// PLLEN [24]
	REG32_SET_BIT(GD32E503_RCU(GD32E503_RCU_CTL), 24, 0b0);
	// CKMEN [19]
	REG32_SET_BIT(GD32E503_RCU(GD32E503_RCU_CTL), 19, 0b0);
	// HXTALEN [16]
	REG32_SET_BIT(GD32E503_RCU(GD32E503_RCU_CTL), 16, 0b0);
	// IRC8MEN [0]
	REG32_SET_BIT(GD32E503_RCU(GD32E503_RCU_CTL), 0, 0b0);
	
	// GD32E503_RCU_CTL
	// IRC8MSTB [1]
	while(!REG32_GET_BIT(GD32E503_RCU(GD32E503_RCU_CTL), 1));
	
	// GD32E503_RCU_INT
	// CKMIC [23] 0b1
	// PLLSTBIC [20] 0b1
	// HXTALSTBIC [19] 0b1
	// IRC8MSTBIC [18] 0b1
	// LXTALSTBIC [17] 0b1
	// IRC40KSTBIC [16] 0b1
	// PLLSTBIE [12] 0b0
	// HXTALSTBIE [11] 0b0
	// IRC8MSTBIE [10] 0b0
	// LXTALSTBIE [9] 0b0
	// IRC40KSTBIE [8] 0b0
	REG32_SET(GD32E503_RCU(GD32E503_RCU_INT), 0x9F0000);
	
	// GD32E503_RCU_ADDINT
	// IRC48MSTBIC [22] 0b1
	// IRC48MSTBIE [14] 0b0
	REG32_SET(GD32E503_RCU(GD32E503_RCU_ADDINT), 0x400000);
	
	// GD32E503_RCU_CFG0
	REG32_SET(GD32E503_RCU(GD32E503_RCU_CFG0), 0);
	// GD32E503_RCU_CFG1
	REG32_SET(GD32E503_RCU(GD32E503_RCU_CFG1), 0);
	// GD32E503_RCU_CFG2
	REG32_SET(GD32E503_RCU(GD32E503_RCU_CFG2), 0);
	// GD32E503_RCU_AHBEN
	REG32_SET(GD32E503_RCU(GD32E503_RCU_AHBEN), 0);
	// GD32E503_RCU_APB1EN
	REG32_SET(GD32E503_RCU(GD32E503_RCU_APB1EN), 0);
	// GD32E503_RCU_APB2EN
	REG32_SET(GD32E503_RCU(GD32E503_RCU_APB2EN), 0);
	// GD32E503_RCU_ADDAPB1EN
	REG32_SET(GD32E503_RCU(GD32E503_RCU_ADDAPB1EN), 0);
	// GD32E503_RCU_BDCTL
	REG32_SET(GD32E503_RCU(GD32E503_RCU_BDCTL), 0);
	// GD32E503_RCU_ADDCTL
	REG32_SET(GD32E503_RCU(GD32E503_RCU_ADDCTL), 0);
	
	// GD32E503_RCU_CTL
	// Oscillator 8MHz
	// HXTALBPS [18] 0b1
	REG32_SET_BIT(GD32E503_RCU(GD32E503_RCU_CTL), 18, 0b1);
	// HXTALEN [16] 0b1
	// CK_HXTAL = 8MHz
	REG32_SET_BIT(GD32E503_RCU(GD32E503_RCU_CTL), 16, 0b1);
	
	// GD32E503_RCU_CTL
	// HTALSTB [17]
	while(!REG32_GET_BIT(GD32E503_RCU(GD32E503_RCU_CTL), 17));
	
	// GD32E503_RCU_CTL
	// CKMEN [19] 0b1 HXTAL monitor enable
	REG32_SET_BIT(GD32E503_RCU(GD32E503_RCU_CTL), 19, 0b1);
	
	// GD32E503_RCU_CFG1
	// PLLPRESEL [30] 0b0 HXTAL as source
	
	// GD32E503_RCU_CFG0
	// PREDV0 [17] 0b1 Divide by 2
	REG32_SET_BIT(GD32E503_RCU(GD32E503_RCU_CFG0), 17, 0b1);
	// PLLSEL [16] 0b1 HXATL or IRC48M as source
	// PSC_PLL = CK_HXTAL / 2 = 4MHz
	REG32_SET_BIT(GD32E503_RCU(GD32E503_RCU_CFG0), 16, 0b1);
	
	// PLLMF[5] [30] 0b0
	// PLLMF[4] [27] 0b1
	REG32_SET_BIT(GD32E503_RCU(GD32E503_RCU_CFG0), 27, 0b1);
	// PLLMF[3:0] [21:18] 0b1000
	// PLLMF 0b011000 CK_PLL = PSC_PLL x 25 = 100MHz
	REG32_SET_RANGE(GD32E503_RCU(GD32E503_RCU_CFG0), 21, 18, 0b1000);
	
	// GD32E503_RCU_CTL
	// PLLEN [24]
	REG32_SET_BIT(GD32E503_RCU(GD32E503_RCU_CTL), 24, 0b1);
	
	// GD32E503_RCU_CTL
	// PLLSTB [25]
	while(!REG32_GET_BIT(GD32E503_RCU(GD32E503_RCU_CTL), 25));
	
	// AHB APB Slow down
	//
	// GD32E503_RCU_CFG0
	// APB2PSC [13:11] 0b111 CK_AHB / 16
	REG32_SET_RANGE(GD32E503_RCU(GD32E503_RCU_CFG0), 13, 11, 0b111);
	// APB1PSC [10:8] 0b111 CK_AHB / 16
	REG32_SET_RANGE(GD32E503_RCU(GD32E503_RCU_CFG0), 10, 8, 0b111);
	// AHBPSC [7:4] 0b1000 CK_SYS / 2
	REG32_SET_RANGE(GD32E503_RCU(GD32E503_RCU_CFG0), 7, 4, 0b1000);
	
	// SCS [1:0] 0b10 PLL as CK_SYS
	REG32_SET_RANGE(GD32E503_RCU(GD32E503_RCU_CFG0), 1, 0, 0b10);
	
	// GD32E503_RCU_CTL
	// SCSS [3:2] 0b10 CK_PLL as CK_SYS
	while(REG32_GET_RANGE(GD32E503_RCU(GD32E503_RCU_CFG0), 3, 2) != 0b10);
	
	// AHB Speed up max 180MHz
	//
	// GD32E503_RCU_CFG0
	// AHBPSC [7:4] 0b0000 CK_AHB = CK_SYS / 1 = 100MHz
	REG32_SET_RANGE(GD32E503_RCU(GD32E503_RCU_CFG0), 7, 4, 0b0000);
	
	// APB1 Speed up max 90MHz
	//
	// GD32E503_RCU_CFG0
	// APB1PSC [10:8] 0b100 CK_APB1 = CK_AHB / 2 = 50MHz
	REG32_SET_RANGE(GD32E503_RCU(GD32E503_RCU_CFG0), 10, 8, 0b100);
	
	// APB2 Speed up max 180MHz
	//
	// APB2PSC [13:11] 0b000 CK_APB2 = CK_AHB / 1 = 100MHz
	REG32_SET_RANGE(GD32E503_RCU(GD32E503_RCU_CFG0), 13, 11, 0b000);
	
	//
	// Pin mux
	//
	if(initGpio())
		return -1;
	
	// JTAG/SWJ SWD
	//
	// GD32E503_AFIO_PCF0
	// SWJ_CFG [26:24] 0b010 Disable JTAG-DP and enable SW-DP
	REG32_SET_RANGE(GD32E503_AFIO(GD32E503_AFIO_PCF0), 26, 24, 0b010);
	
	// Watchdog
	// PA8 WDI
	//
	// GD32E503_AFIO_PCFA
	// PA8_AFCFG [17:16] 0b00 GPIO
	REG32_SET_RANGE(GD32E503_AFIO(GD32E503_AFIO_PCFA), 17, 16, 0b00);
	
	// Case address
	// PC0 CASE_ADDR0
	// PC1 CASE_ADDR1
	// PC2 CASE_PARITY
	//
	// GD32E503_AFIO_PCFC
	// PC0_AFCFG [0] 0b0 No alternate
	REG32_SET_BIT(GD32E503_AFIO(GD32E503_AFIO_PCFC), 0, 0b0);
	// PC2_AFCFG [5:4] 0b00 No alternate
	REG32_SET_RANGE(GD32E503_AFIO(GD32E503_AFIO_PCFC), 5, 4, 0b00);
	
	// Slot address
	// PE9 SLOT_ADDR0
	// PE8 SLOT_ADDR1
	// PE7 SLOT_ADDR2
	// PB3 SLOT_ADDR3
	// PC3 SLOT_PARITY
	//
	// GD32E503_AFIO_PCFE
	// PE9_AFCFG [18] 0b0 No alternate
	REG32_SET_BIT(GD32E503_AFIO(GD32E503_AFIO_PCFE), 18, 0b0);
	// PE8_AFCFG [16] 0b0 No alternate
	REG32_SET_BIT(GD32E503_AFIO(GD32E503_AFIO_PCFE), 16, 0b0);
	// GD32E503_AFIO_PCFB
	// PB3_AFCFG [6] 0b0 No alternate
	REG32_SET_BIT(GD32E503_AFIO(GD32E503_AFIO_PCFB), 6, 0b0);
	// GD32E503_AFIO_PCFC
	// PC3_AFCFG [6] 0b0 No alternate
	REG32_SET_BIT(GD32E503_AFIO(GD32E503_AFIO_PCFC), 6, 0b0);
	
	// SYN bus
	//
	// PA1 SYN_RX TIMER1_CH1
	// GD32E503_AFIO_PCF0
	// TIMER1_REMAP [9:8] 0b00 (TIMER1_CH0/TIMER1_ETI/PA0, TIMER1_CH1/PA1, TIMER1_CH2/PA2, TIMER1_CH3/PA3)
	REG32_SET_RANGE(GD32E503_AFIO(GD32E503_AFIO_PCF0), 9, 8, 0b00);
	// PA6 SYN_TX
	// PA4 SYN_TE
	
	// UTC bus
	//
	// PA3 UTC_RX TIMER1_CH3
	// GD32E503_AFIO_PCF0
	// TIMER1_REMAP [9:8] 0b00 (TIMER1_CH0/TIMER1_ETI/PA0, TIMER1_CH1/PA1, TIMER1_CH2/PA2, TIMER1_CH3/PA3)
	// PA2 UTC_TX TIMER1_CH2
	// GD32E503_AFIO_PCF0
	// TIMER1_REMAP [9:8] 0b00 (TIMER1_CH0/TIMER1_ETI/PA0, TIMER1_CH1/PA1, TIMER1_CH2/PA2, TIMER1_CH3/PA3)
	// PA5 UTC_TE
	REG32_SET_BIT(GD32E503_AFIO(GD32E503_AFIO_PCFA), 10, 0b0);
	
	// GPDI
	//
	// PC9 DI0
	REG32_SET_RANGE(GD32E503_AFIO(GD32E503_AFIO_PCFC), 19, 18, 0b00);
	// PC7 DI1
	REG32_SET_RANGE(GD32E503_AFIO(GD32E503_AFIO_PCFC), 15, 14, 0b00);
	// PD15 DI2
	// PB11 DI3
	REG32_SET_RANGE(GD32E503_AFIO(GD32E503_AFIO_PCFB), 23, 22, 0b00);
	// PE15 DI4
	// PE13 DI5
	REG32_SET_BIT(GD32E503_AFIO(GD32E503_AFIO_PCFE), 26, 0b0);
	// PC10 DI6
	REG32_SET_BIT(GD32E503_AFIO(GD32E503_AFIO_PCFC), 20, 0b0);
	// PC12 DI7
	REG32_SET_BIT(GD32E503_AFIO(GD32E503_AFIO_PCFC), 24, 0b0);
	// PD1 DI8
	// PD3 DI9
	// PD5 DI10
	REG32_SET_BIT(GD32E503_AFIO(GD32E503_AFIO_PCFD), 10, 0b0);
	// PD7 DI11
	// PD2 DI12
	// PD4 DI13
	REG32_SET_BIT(GD32E503_AFIO(GD32E503_AFIO_PCFD), 8, 0b0);
	// PE0 DI14
	REG32_SET_RANGE(GD32E503_AFIO(GD32E503_AFIO_PCFE), 1, 0, 0b00);
	// PE2 DI15
	// PD13 DI16
	// PD12 DI17
	// PE1 DI18
	REG32_SET_RANGE(GD32E503_AFIO(GD32E503_AFIO_PCFE), 3, 2, 0b00);
	// PB15 DI19
	REG32_SET_BIT(GD32E503_AFIO(GD32E503_AFIO_PCFB), 30, 0b0);
	// PD8 DI20
	// PD9 DI21
	// PD10 DI22
	// PD11 DI23
	
	// GPDO
	//
	// PC13 DO0
	// PE6 DO1
	// PE5 DO2
	// PE4 DO3
	// PC8 DO4
	REG32_SET_RANGE(GD32E503_AFIO(GD32E503_AFIO_PCFC), 17, 16, 0b00);
	// PC6 DO5
	REG32_SET_RANGE(GD32E503_AFIO(GD32E503_AFIO_PCFE), 13, 12, 0b00);
	// PD14 DO6
	// PB10 DO7
	REG32_SET_RANGE(GD32E503_AFIO(GD32E503_AFIO_PCFB), 21, 20, 0b00);
	// PE14 DO8
	// PE12 DO9
	REG32_SET_BIT(GD32E503_AFIO(GD32E503_AFIO_PCFE), 12, 0b0);
	// PC11 DO10
	REG32_SET_RANGE(GD32E503_AFIO(GD32E503_AFIO_PCFC), 23, 22, 0b00);
	// PD0 DO11
	// PD2 DO12
	// PD4 DO13
	REG32_SET_BIT(GD32E503_AFIO(GD32E503_AFIO_PCFD), 4, 0b0);
	// PD6 DO14
	// PB5 DO15
	REG32_SET_RANGE(GD32E503_AFIO(GD32E503_AFIO_PCFB), 11, 10, 0b00);
	// PB7 DO16
	REG32_SET_BIT(GD32E503_AFIO(GD32E503_AFIO_PCFB), 14, 0b0);
	// PB9 DO17
	REG32_SET_RANGE(GD32E503_AFIO(GD32E503_AFIO_PCFB), 19, 18, 0b00);
	// PE1 DO18
	REG32_SET_RANGE(GD32E503_AFIO(GD32E503_AFIO_PCFE), 3, 2, 0b00);
	// PE3 DO19
	
	// LED
	// PE10 GREEN
	// PE11 RED
	//
	// GD32E503_AFIO_PCFE
	// PE10_AFCFG [20] 0b0 No alternate
	REG32_SET_BIT(GD32E503_AFIO(GD32E503_AFIO_PCFE), 20, 0b0);
	// PE11_AFCFG [22] 0b0 No alternate
	REG32_SET_BIT(GD32E503_AFIO(GD32E503_AFIO_PCFE), 22, 0b0);
	
	// USART0
	// PA9 USART0_TX
	// PA10 USART0_RX
	//
	// GD32E503_RCU_APB2RST
	// USART0RST [14]
	REG32_SET_BIT(GD32E503_RCU(GD32E503_RCU_APB2RST), 14, 0b1);
	// GD32E503_RCU_APB2EN
	// USART0EN [14]
	REG32_SET_BIT(GD32E503_RCU(GD32E503_RCU_APB2EN), 14, 0b1);
	// GD32E503_AFIO_PCFA
	// PA9_AFCFG [19:18] 0b00 No alternate
	REG32_SET_RANGE(GD32E503_AFIO(GD32E503_AFIO_PCFA), 19, 18, 0b00);
	// PA10_AFCFG [21:20] 0b00 No alternate
	REG32_SET_RANGE(GD32E503_AFIO(GD32E503_AFIO_PCFA), 21, 20, 0b00);
	// GD32E503_AFIO_PCF0
	// USART0_REMAP [2] 0b0 (USART0_TX/PA9, USART0_RX/PA10)
	REG32_SET_BIT(GD32E503_AFIO(GD32E503_AFIO_PCF0), 2, 0b0);
	// GD32E503_RCU_APB2RST
	// USART0RST [14]
	REG32_SET_BIT(GD32E503_RCU(GD32E503_RCU_APB2RST), 14, 0b0);
	
	// CAN0
	// PA11 CAN0_RX
	// PA12 CAN0_TX
	//
	// GD32E503_RCU_APB1RST
	// CAN0RST [25]
	REG32_SET_BIT(GD32E503_RCU(GD32E503_RCU_APB1RST), 25, 0b1);
	// GD32E503_RCU_APB1EN
	// CAN0EN [25]
	REG32_SET_BIT(GD32E503_RCU(GD32E503_RCU_APB1EN), 25, 0b1);
	// GD32E503_AFIO_PCFA
	// PA11_AFCFG [23:22] 0b00 No alternate
	REG32_SET_RANGE(GD32E503_AFIO(GD32E503_AFIO_PCFA), 23, 22, 0b00);
	// PA12_AFCFG [25:24] 0b00 No alternate
	REG32_SET_RANGE(GD32E503_AFIO(GD32E503_AFIO_PCFA), 25, 24, 0b00);
	// GD32E503_AFIO_PCF0
	// CAN0_REMAP [14:13] 0b00 (CAN0_RX/PA11, CAN0_TX/PA12)
	REG32_SET_RANGE(GD32E503_AFIO(GD32E503_AFIO_PCF0), 14, 13, 0b00);
	// GD32E503_RCU_APB1RST
	// CAN0RST [25]
	REG32_SET_BIT(GD32E503_RCU(GD32E503_RCU_APB1RST), 25, 0b0);
	
	// CAN1
	// PB12 CAN1_RX
	// PB13 CAN1_TX
	//
	// GD32E503_RCU_APB1RST
	// CAN1RST [26]
	REG32_SET_BIT(GD32E503_RCU(GD32E503_RCU_APB1RST), 26, 0b1);
	// GD32E503_RCU_APB1EN
	// CAN1EN [26]
	REG32_SET_BIT(GD32E503_RCU(GD32E503_RCU_APB1EN), 26, 0b1);
	// GD32E503_AFIO_PCFB
	// PB12_AFCFG [25:24] 0b00 No alternate
	REG32_SET_RANGE(GD32E503_AFIO(GD32E503_AFIO_PCFB), 25, 24, 0b00);
	// PB13_AFCFG [27:26] 0b00 No alternate
	REG32_SET_RANGE(GD32E503_AFIO(GD32E503_AFIO_PCFB), 27, 26, 0b00);
	// GD32E503_AFIO_PCF0
	// CAN1_REMAP [22] 0b0 (CAN1_RX/PB12, CAN1_TX/PB13)
	REG32_SET_BIT(GD32E503_RCU(GD32E503_AFIO_PCF0), 22, 0b0);
	// GD32E503_RCU_APB1RST
	// CAN1RST [26]
	REG32_SET_BIT(GD32E503_RCU(GD32E503_RCU_APB1RST), 26, 0b0);
	
	// Watchdog
	if(initWdog())
		return -2;
	feedHardDog();
	
	// UniTimeX
	if(initUniTimeX())
		return -3;
	
	return 0;
}
